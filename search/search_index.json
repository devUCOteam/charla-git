{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de iniciaci\u00f3n a git Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias . Contenido Inicio Introducci\u00f3n a Git Instalaci\u00f3n y configuraci\u00f3n de git Uso b\u00e1sico Uso avanzado Ramas Entornos gr\u00e1ficos Github Flujo de trabajo con Git (git flow) Referencias","title":"Inicio"},{"location":"#taller-de-iniciacion-a-git","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias .","title":"Taller de iniciaci\u00f3n a git"},{"location":"#contenido","text":"Inicio Introducci\u00f3n a Git Instalaci\u00f3n y configuraci\u00f3n de git Uso b\u00e1sico Uso avanzado Ramas Entornos gr\u00e1ficos Github Flujo de trabajo con Git (git flow) Referencias","title":"Contenido"},{"location":"EntornoGrafico/","text":"Entornos gr\u00e1ficos para Git Existen varios entornos gr\u00e1ficos que permiten la gesti\u00f3n de repositorios con git. El m\u00e1s famoso es GitKraken GitKraken es gratuito en sus funcionalidades gratis pero no en su totalidad. Editores de c\u00f3digo y IDE Algunos editores de c\u00f3digo y todo IDE que se precie tiene implementaci\u00f3n directa con Git. Atom Atom por ejemplo tiene una herramienta muy completa de Git que, adem\u00e1s de permitirte realizar los commits de forma sencilla te marca las diferencias que hay entre tu repositorio y el archivo que est\u00e1s editando de manera muy clara. No es cosa rara que este editor de c\u00f3digo tenga tal integraci\u00f3n puesto que Atom pertenece a github. VScode VScode es un IDE que tiene integraci\u00f3n nativa con git pr\u00e1cticamente igual a la de atom. Esta integraci\u00f3n es muy f\u00e1cil de usar pero quiz\u00e1s se queda corta cuando hay alg\u00fan conflicto. Hemos puesto solo algunos ejemplos de editores que tienen integraci\u00f3n con git, hay muchos m\u00e1s y te animamos que pruebes todos los que puedas para encontrar la herramienta con la que estes mas agusto trabajando.","title":"Entornos gr\u00e1ficos"},{"location":"EntornoGrafico/#entornos-graficos-para-git","text":"Existen varios entornos gr\u00e1ficos que permiten la gesti\u00f3n de repositorios con git. El m\u00e1s famoso es GitKraken GitKraken es gratuito en sus funcionalidades gratis pero no en su totalidad.","title":"Entornos gr\u00e1ficos para Git"},{"location":"EntornoGrafico/#editores-de-codigo-y-ide","text":"Algunos editores de c\u00f3digo y todo IDE que se precie tiene implementaci\u00f3n directa con Git.","title":"Editores de c\u00f3digo y IDE"},{"location":"EntornoGrafico/#atom","text":"Atom por ejemplo tiene una herramienta muy completa de Git que, adem\u00e1s de permitirte realizar los commits de forma sencilla te marca las diferencias que hay entre tu repositorio y el archivo que est\u00e1s editando de manera muy clara. No es cosa rara que este editor de c\u00f3digo tenga tal integraci\u00f3n puesto que Atom pertenece a github.","title":"Atom"},{"location":"EntornoGrafico/#vscode","text":"VScode es un IDE que tiene integraci\u00f3n nativa con git pr\u00e1cticamente igual a la de atom. Esta integraci\u00f3n es muy f\u00e1cil de usar pero quiz\u00e1s se queda corta cuando hay alg\u00fan conflicto. Hemos puesto solo algunos ejemplos de editores que tienen integraci\u00f3n con git, hay muchos m\u00e1s y te animamos que pruebes todos los que puedas para encontrar la herramienta con la que estes mas agusto trabajando.","title":"VScode"},{"location":"git-flow/","text":"Flujo de trabajo con Git (git flow) La importancia de la organizaci\u00f3n del flujo de trabajo En la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n. En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por Vincent Driessen y que podemos ver en la figura siguiente. Las ramas principales En este esquema hay dos ramas principales con un tiempo de vida indefinido: master ( origin/master ): el c\u00f3digo apuntado por HEAD siempre contiene un estado listo para producci\u00f3n. develop ( origin/develop ): el c\u00f3digo apuntado por HEAD siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar rama de integraci\u00f3n . No es necesariamente estable. Cuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama master y una nueva versi\u00f3n es lanzada. Las ramas auxiliares Para labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan: Ramas de funcionalidad (feature branches) Ramas de versi\u00f3n (release branches) Ramas de parches (hotfix branches) Feature branches Pueden partir de: develop Deben fusionarse con: develop Convenici\u00f3n de nombres: feature-NUMissue-*. Release branches Pueden partir de: develop Deben fusionarse con: develop y master Convenici\u00f3n de nombres: release-* Hotfix branches Pueden partir de: master Deben fusionarse con: develop y master Convenici\u00f3n de nombres: hotfix-* La extensi\u00f3n flow de Git Una de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es gitflow , que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo. Instalaci\u00f3n Aunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en petervanderdoes/gitflow . En el wiki del repositorio est\u00e1n las instrucciones de instalaci\u00f3n para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden: git flow . Uso Para cambiar a las ramas master y develop, seguiremos usando git checkout , pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes: git flow init : Permite inicializar el espacio de trabajo. git flow feature : Permite crear y trabajar con ramas de funcionalidades. git flow release : Permite crear y trabajar con ramas de versiones. git flow hotfix : Permite crear y trabajar con ramas de parches. En el siguiente cap\u00edtulo veremos como usarlas para trabajar en un proyecto ya creado.","title":"Flujo de trabajo con Git (git flow)"},{"location":"git-flow/#flujo-de-trabajo-con-git-git-flow","text":"","title":"Flujo de trabajo con Git (git flow)"},{"location":"git-flow/#la-importancia-de-la-organizacion-del-flujo-de-trabajo","text":"En la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n. En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por Vincent Driessen y que podemos ver en la figura siguiente.","title":"La importancia de la organizaci\u00f3n del flujo de trabajo"},{"location":"git-flow/#las-ramas-principales","text":"En este esquema hay dos ramas principales con un tiempo de vida indefinido: master ( origin/master ): el c\u00f3digo apuntado por HEAD siempre contiene un estado listo para producci\u00f3n. develop ( origin/develop ): el c\u00f3digo apuntado por HEAD siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar rama de integraci\u00f3n . No es necesariamente estable. Cuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama master y una nueva versi\u00f3n es lanzada.","title":"Las ramas principales"},{"location":"git-flow/#las-ramas-auxiliares","text":"Para labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan: Ramas de funcionalidad (feature branches) Ramas de versi\u00f3n (release branches) Ramas de parches (hotfix branches)","title":"Las ramas auxiliares"},{"location":"git-flow/#feature-branches","text":"Pueden partir de: develop Deben fusionarse con: develop Convenici\u00f3n de nombres: feature-NUMissue-*.","title":"Feature branches"},{"location":"git-flow/#release-branches","text":"Pueden partir de: develop Deben fusionarse con: develop y master Convenici\u00f3n de nombres: release-*","title":"Release branches"},{"location":"git-flow/#hotfix-branches","text":"Pueden partir de: master Deben fusionarse con: develop y master Convenici\u00f3n de nombres: hotfix-*","title":"Hotfix branches"},{"location":"git-flow/#la-extension-flow-de-git","text":"Una de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es gitflow , que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo.","title":"La extensi\u00f3n flow de Git"},{"location":"git-flow/#instalacion","text":"Aunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en petervanderdoes/gitflow . En el wiki del repositorio est\u00e1n las instrucciones de instalaci\u00f3n para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden: git flow .","title":"Instalaci\u00f3n"},{"location":"git-flow/#uso","text":"Para cambiar a las ramas master y develop, seguiremos usando git checkout , pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes: git flow init : Permite inicializar el espacio de trabajo. git flow feature : Permite crear y trabajar con ramas de funcionalidades. git flow release : Permite crear y trabajar con ramas de versiones. git flow hotfix : Permite crear y trabajar con ramas de parches. En el siguiente cap\u00edtulo veremos como usarlas para trabajar en un proyecto ya creado.","title":"Uso"},{"location":"github/","text":"Github \u00bfQu\u00e9 es github? Git es un control de versiones que nos permite trabajar comodamente con m\u00faltiples versiones de nuestro c\u00f3digo, sin embargo, cuando estamos trabajando en el mundo normal, lo general es estar colaborando con otras personas en el mismo proycto. Esta funcionalidad se realiza de forma m\u00e1s c\u00f3moda mediante Github. Github es un proyecto independiente a git Debemos tener clara la anterior afirmaci\u00f3n, puesto que Github simplemente es un repositorio donde podemos encontrar m\u00faltiples proyectos cuyo control de versiones es git , es una plataforma muy \u00fatil de usar para la comunicaci\u00f3n entre los diferentes equipos. Antes de continuar ser\u00e1 neceseario obtener nuestra cuenta de Github Sincronizaci\u00f3n de Github y Git Cuando estamos trabajando con git estamos haciendo repositorios locales, dichos repositorios estan alojados en nuestro equipo aislados del resto del mundo. Al querer trabajar con Github, ser\u00e1 necesario sincronizar los cambios que hagamos en local con los cambios en remoto (dentro de nuestro repositorio Github) para ello tenemos dos opciones de trabajar: Autenticaci\u00f3n mediante HTTP Utilizar claves SSH Autenticaci\u00f3n HTTP Consiste en introducir nuestro usuario y contrase\u00f1a en el caso de que queramos realizar operaciones en remoto ( como pueden ser obtener los cambios o subir nuevos cambios), para ello simplemente tenemos que configurar nuestra cuenta de Github. En el caso de estar trabajando con claves HTTP, para ahorrar tiempo podemos introducir la contrase\u00f1a en cach\u00e9 de forma que no la requiera cada vez que tengamos que realizar operaciones remotas, para ello es necesario activar la cach\u00e9 mediante el siguiente comando: git config --global credential.helper 'cache --timeout=3600' Autenticaci\u00f3n con SSH Github tiene una opci\u00f3n muy \u00fatil que consiste en poder sincronizar las claves ssh con Github de forma que podamos realizar cambios sin necesidad de introducir nuestro usuario y contrase\u00f1a de Github. Si queremos configurar nuestra clave ssh dentro del repositorio de Github, necesitaremos generarla, para ello introduciremos el siguiente comando en la terminal. ssh-keygen -b 4096 De forma que por defecto (aunque podemos cambiarlo dentro del asistente de generaci\u00f3n) se guardar\u00e1n los archivos id_rsa y id_rsa.pub dentro de la carpeta ~/.ssh de nuestro usuario, pudiendo as\u00ed copiar el contenido del \u00faltimo archivo a la configuraci\u00f3n de nuestro perfil de Github: Convertir un repositorio en remoto Como se ha mencionado con anterioridad, cuando estamos trabajando con git lo estamos haciendo de forma local, sin embargo cuando queremos sincronizar dichos cambios con Github, simplemente tenemos que indicarle a git a que repositorio de git tiene que enviarlo, para ello tenemos que ejecutar el siguiente comando: git remote add origin url Tenemos que tener en cuenta que la url, ser\u00e1 http si estamos trabajando con este m\u00e9todo de autenticaci\u00f3n o ssh en el caso de tener configurada la clave p\u00fablica, ambas opciones nos la facilita Github cuando creamos un nuevo repositorio Clonar un repositorio Al hablar de Github mencionamos que exist\u00edan m\u00faltiples repositorios creados por numerosas personas, todos usando el git como control de versiones. \u00bfQu\u00e9 pasa si quiero obtener el repositorio de una persona? Esta pregunta muy frecuente podemos solucionarla con la opci\u00f3n clone de git. Esta opci\u00f3n nos permite obtener le repositorio (con todos los cambios que se han realizado) sobre cualquier proyecto p\u00fablico de Github. Un aspecto a tener en cuenta es que esta operaci\u00f3n es que si constamos como colaborador en dicho proyecto podemos realizar todas las operaciones (puesto que se obtienen la configuraci\u00f3n del mismo) Para clonar un repositorio cualquiera simplemente tenemos que ejecutar: git clone url Ver repostorios remotos Cuando estamos trabajando en un proyecto, generalmente subimos todos los cambios a un solo repositorio de Github, sin embargo, es posible que estemos trabajando en diferentes repositorios por diversos motivos. Uno de estos motivos puede ser que estemos obteniendo el c\u00f3digo de un repositorio determinado y subiendo nuestros cambios a uno propio. Para poder llevar el control de los repositorio remotos asociados a nuestro repositorio local, utilizamos el siguiente comando: git remote -v Si queremos eliminar cualquier repositorio remoto de nuestro repositorio local simplemente podemos borrar el reositiorio haciendo uso del comando git remote rm origin Obteniendo y aplicando datos en un repositorio remoto Cuando hemos terminado de trabajar en nuestro repositorio local, realizados todos nuestros commits y agregados los archivos pertinentes, pasaremos a aplicar los cambios en el repositorio remoto, para ello usaremos el siguiente comando: git push -u origin master Teniendo en cuenta que origin har\u00e1 referencia al repositorio remoto con el que estamos trabajando, mientras que master hace referencia a la rama en la que estamos trabajando en nuestro repositorio local. Para obtener los cambios realizados por nosotros (u otras personas) en el repositorio remoto utilizamos: git pull origin master Haciendo referencia de nuevo a master como la rama en la que queremos obtener los cambios. Debemos tener en cuenta que antes de realizar cualquier git push es recomendable hacer un git pull para evitar posibles errores a la hora de subir los cambios al repositorio remoto Trabajando con ramas remotas Las ramas (de lo cual se ha hablado con anterioridad), es un elemento de git que puede ser trasladado a Github sin ning\u00fan problema. Esto permite a los usuarios trabajar en remoto sin problema alguno. Podemos ver las ramas remotas de nuestro repositorio con: git branch -r Operaciones con ramas remotas Las mismas operaciones (crear,modificar,eliminar) que pod\u00edamos hacer con las ramas locales podr\u00e9mos hacerlas con las remotas sin nig\u00fan tipo de problema, simplemente tendr\u00e9mos que haber creado las ramas remotas previamente y aplicar los diferentes cambios que hagamos en local. Crear y modficiar ramas remota Para crear una rama remota, tenemos que seguir los siguientes pasos: Crear una rama en local git branch nueva rama Modificar la rama local Hacer commit Crear la rama remota git push origin rama1 De nuevo hacemos referencia a origin como la rama remota y rama1 como la rama local en la que estamos trabajando y queremos sincronizar con el repositorio remoto Si llevamos cierto tiempo trabajando con una rama en nuestro repositorio local, podemos copiar dicha rama al repositorio remoto usando: git checkout -b rama_local rama_remota Eliminar ramas remotas Al igual podemos eliminar una rama del repositorio remoto: git push origin --delete rama_remota Obtener datos de ramas remotas Una vez que tenemos contenido en ramas locales,ser\u00eda de utilidad poder traerlo a nuestro repositorio local de forma que podamos explorar y probar las nuevas funcionalidades implementadas por cualquier compa\u00f1ero (como ejemplo personal). Para poder obtener todos los cambios remotos utilizamos el comando: git fetch Si estamos trabajando en una rama local y queremos fusionarla con las ramas remotas tendr\u00e9mos que usar el comando git merge origin/master De forma que estamos sincronizando completamente nuestr rama local master con nuestra rama remota ( master en el repositorio remoto ), en el caso de que tengamos problemas de sincronizaci\u00f3n Github tiene los denominados pull merge requests que quedar\u00e1n registrados como un commit cuando un usuario decide fusionar su rama local con la remota. Cuando queremos obtener los cambios en la rama en la que estamos trabajando simplemente tenemos que recurrir al comando visto con anterioridad: git pull Trabajo din\u00e1mico con repositorio remotos Cuando estamos explorando repositorios remotos, podemos encontrar alg\u00fan proyecto que te guste modificar o un trabajo que quieras comprobar como funciona. En este caso Github implementa lo denomidado fork que consiste en el clonado de un repositorio remoto (creado por otra persona) a un repositorio remoto (creado por nosotros) de forma que podamos modificar libremente una copia exacta del repositorio ajeno Una vez que hemos copiado el remoto ajeno a uno personal podemos trabajar libremente como mencionamos anteriormente.","title":"Github"},{"location":"github/#github","text":"","title":"Github"},{"location":"github/#que-es-github","text":"Git es un control de versiones que nos permite trabajar comodamente con m\u00faltiples versiones de nuestro c\u00f3digo, sin embargo, cuando estamos trabajando en el mundo normal, lo general es estar colaborando con otras personas en el mismo proycto. Esta funcionalidad se realiza de forma m\u00e1s c\u00f3moda mediante Github. Github es un proyecto independiente a git Debemos tener clara la anterior afirmaci\u00f3n, puesto que Github simplemente es un repositorio donde podemos encontrar m\u00faltiples proyectos cuyo control de versiones es git , es una plataforma muy \u00fatil de usar para la comunicaci\u00f3n entre los diferentes equipos. Antes de continuar ser\u00e1 neceseario obtener nuestra cuenta de Github","title":"\u00bfQu\u00e9 es github?"},{"location":"github/#sincronizacion-de-github-y-git","text":"Cuando estamos trabajando con git estamos haciendo repositorios locales, dichos repositorios estan alojados en nuestro equipo aislados del resto del mundo. Al querer trabajar con Github, ser\u00e1 necesario sincronizar los cambios que hagamos en local con los cambios en remoto (dentro de nuestro repositorio Github) para ello tenemos dos opciones de trabajar: Autenticaci\u00f3n mediante HTTP Utilizar claves SSH","title":"Sincronizaci\u00f3n de Github y Git"},{"location":"github/#autenticacion-http","text":"Consiste en introducir nuestro usuario y contrase\u00f1a en el caso de que queramos realizar operaciones en remoto ( como pueden ser obtener los cambios o subir nuevos cambios), para ello simplemente tenemos que configurar nuestra cuenta de Github. En el caso de estar trabajando con claves HTTP, para ahorrar tiempo podemos introducir la contrase\u00f1a en cach\u00e9 de forma que no la requiera cada vez que tengamos que realizar operaciones remotas, para ello es necesario activar la cach\u00e9 mediante el siguiente comando: git config --global credential.helper 'cache --timeout=3600'","title":"Autenticaci\u00f3n HTTP"},{"location":"github/#autenticacion-con-ssh","text":"Github tiene una opci\u00f3n muy \u00fatil que consiste en poder sincronizar las claves ssh con Github de forma que podamos realizar cambios sin necesidad de introducir nuestro usuario y contrase\u00f1a de Github. Si queremos configurar nuestra clave ssh dentro del repositorio de Github, necesitaremos generarla, para ello introduciremos el siguiente comando en la terminal. ssh-keygen -b 4096 De forma que por defecto (aunque podemos cambiarlo dentro del asistente de generaci\u00f3n) se guardar\u00e1n los archivos id_rsa y id_rsa.pub dentro de la carpeta ~/.ssh de nuestro usuario, pudiendo as\u00ed copiar el contenido del \u00faltimo archivo a la configuraci\u00f3n de nuestro perfil de Github:","title":"Autenticaci\u00f3n con SSH"},{"location":"github/#convertir-un-repositorio-en-remoto","text":"Como se ha mencionado con anterioridad, cuando estamos trabajando con git lo estamos haciendo de forma local, sin embargo cuando queremos sincronizar dichos cambios con Github, simplemente tenemos que indicarle a git a que repositorio de git tiene que enviarlo, para ello tenemos que ejecutar el siguiente comando: git remote add origin url Tenemos que tener en cuenta que la url, ser\u00e1 http si estamos trabajando con este m\u00e9todo de autenticaci\u00f3n o ssh en el caso de tener configurada la clave p\u00fablica, ambas opciones nos la facilita Github cuando creamos un nuevo repositorio","title":"Convertir un repositorio en remoto"},{"location":"github/#clonar-un-repositorio","text":"Al hablar de Github mencionamos que exist\u00edan m\u00faltiples repositorios creados por numerosas personas, todos usando el git como control de versiones. \u00bfQu\u00e9 pasa si quiero obtener el repositorio de una persona? Esta pregunta muy frecuente podemos solucionarla con la opci\u00f3n clone de git. Esta opci\u00f3n nos permite obtener le repositorio (con todos los cambios que se han realizado) sobre cualquier proyecto p\u00fablico de Github. Un aspecto a tener en cuenta es que esta operaci\u00f3n es que si constamos como colaborador en dicho proyecto podemos realizar todas las operaciones (puesto que se obtienen la configuraci\u00f3n del mismo) Para clonar un repositorio cualquiera simplemente tenemos que ejecutar: git clone url","title":"Clonar un repositorio"},{"location":"github/#ver-repostorios-remotos","text":"Cuando estamos trabajando en un proyecto, generalmente subimos todos los cambios a un solo repositorio de Github, sin embargo, es posible que estemos trabajando en diferentes repositorios por diversos motivos. Uno de estos motivos puede ser que estemos obteniendo el c\u00f3digo de un repositorio determinado y subiendo nuestros cambios a uno propio. Para poder llevar el control de los repositorio remotos asociados a nuestro repositorio local, utilizamos el siguiente comando: git remote -v Si queremos eliminar cualquier repositorio remoto de nuestro repositorio local simplemente podemos borrar el reositiorio haciendo uso del comando git remote rm origin","title":"Ver repostorios remotos"},{"location":"github/#obteniendo-y-aplicando-datos-en-un-repositorio-remoto","text":"Cuando hemos terminado de trabajar en nuestro repositorio local, realizados todos nuestros commits y agregados los archivos pertinentes, pasaremos a aplicar los cambios en el repositorio remoto, para ello usaremos el siguiente comando: git push -u origin master Teniendo en cuenta que origin har\u00e1 referencia al repositorio remoto con el que estamos trabajando, mientras que master hace referencia a la rama en la que estamos trabajando en nuestro repositorio local. Para obtener los cambios realizados por nosotros (u otras personas) en el repositorio remoto utilizamos: git pull origin master Haciendo referencia de nuevo a master como la rama en la que queremos obtener los cambios. Debemos tener en cuenta que antes de realizar cualquier git push es recomendable hacer un git pull para evitar posibles errores a la hora de subir los cambios al repositorio remoto","title":"Obteniendo y aplicando datos en un repositorio remoto"},{"location":"github/#trabajando-con-ramas-remotas","text":"Las ramas (de lo cual se ha hablado con anterioridad), es un elemento de git que puede ser trasladado a Github sin ning\u00fan problema. Esto permite a los usuarios trabajar en remoto sin problema alguno. Podemos ver las ramas remotas de nuestro repositorio con: git branch -r","title":"Trabajando con ramas remotas"},{"location":"github/#operaciones-con-ramas-remotas","text":"Las mismas operaciones (crear,modificar,eliminar) que pod\u00edamos hacer con las ramas locales podr\u00e9mos hacerlas con las remotas sin nig\u00fan tipo de problema, simplemente tendr\u00e9mos que haber creado las ramas remotas previamente y aplicar los diferentes cambios que hagamos en local.","title":"Operaciones con ramas remotas"},{"location":"github/#crear-y-modficiar-ramas-remota","text":"Para crear una rama remota, tenemos que seguir los siguientes pasos: Crear una rama en local git branch nueva rama Modificar la rama local Hacer commit Crear la rama remota git push origin rama1 De nuevo hacemos referencia a origin como la rama remota y rama1 como la rama local en la que estamos trabajando y queremos sincronizar con el repositorio remoto Si llevamos cierto tiempo trabajando con una rama en nuestro repositorio local, podemos copiar dicha rama al repositorio remoto usando: git checkout -b rama_local rama_remota","title":"Crear y modficiar ramas remota"},{"location":"github/#eliminar-ramas-remotas","text":"Al igual podemos eliminar una rama del repositorio remoto: git push origin --delete rama_remota","title":"Eliminar ramas remotas"},{"location":"github/#obtener-datos-de-ramas-remotas","text":"Una vez que tenemos contenido en ramas locales,ser\u00eda de utilidad poder traerlo a nuestro repositorio local de forma que podamos explorar y probar las nuevas funcionalidades implementadas por cualquier compa\u00f1ero (como ejemplo personal). Para poder obtener todos los cambios remotos utilizamos el comando: git fetch Si estamos trabajando en una rama local y queremos fusionarla con las ramas remotas tendr\u00e9mos que usar el comando git merge origin/master De forma que estamos sincronizando completamente nuestr rama local master con nuestra rama remota ( master en el repositorio remoto ), en el caso de que tengamos problemas de sincronizaci\u00f3n Github tiene los denominados pull merge requests que quedar\u00e1n registrados como un commit cuando un usuario decide fusionar su rama local con la remota. Cuando queremos obtener los cambios en la rama en la que estamos trabajando simplemente tenemos que recurrir al comando visto con anterioridad: git pull","title":"Obtener datos de ramas remotas"},{"location":"github/#trabajo-dinamico-con-repositorio-remotos","text":"Cuando estamos explorando repositorios remotos, podemos encontrar alg\u00fan proyecto que te guste modificar o un trabajo que quieras comprobar como funciona. En este caso Github implementa lo denomidado fork que consiste en el clonado de un repositorio remoto (creado por otra persona) a un repositorio remoto (creado por nosotros) de forma que podamos modificar libremente una copia exacta del repositorio ajeno Una vez que hemos copiado el remoto ajeno a uno personal podemos trabajar libremente como mencionamos anteriormente.","title":"Trabajo din\u00e1mico con repositorio remotos"},{"location":"instalacion-git/","text":"Aspectos b\u00e1sicos de Git Instalaci\u00f3n Instalando en Linux Si quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum: yum install git-core O si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get: apt-get install git Instalando en Windows Instalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo: http://msysgit.github.com/ Una vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador. Instalando en MacOS En MacOS se recomienda tener instalada la herramienta homebrew . Despu\u00e9s, es tan f\u00e1cil como ejecutar: brew install git Configuraci\u00f3n del entorno git Git tiene ciertos valores por defecto que nos permite comenzar a trabajar despu\u00e9s de la instalaci\u00f3n, sin embargo, cuando estamos trabajando en conjunto con otras personas es necesario identificarnos dentro de git, de forma que podamos identificar los commits que estemos realizado. Para ello modificaremos los siguientes par\u00e1metros. Configuraci\u00f3n de usuario git config --global user.name Nombre de usuario git config --global user.email correo_usuario@gmail.com Con estos sencillos comandos tenemos configurados tanto nuestro nombre de usuario como nuestro correo electr\u00f3nico de forma que al subir nuestros cambios al repositorio remoto aparezca nuestro nombre en \u00e9l. Configuraci\u00f3n de un editor por defecto Cuando estamos trabajando con git, es posible que obtengamos dieferentes mensajes de error, dichos mensajes de error ser\u00e1n mostrados en un editor de texto (que por defecto es vim ), podemos cambiar este editor con el siguiente comando. git config --global core.editor editorFavorito Algunos de los editores que podemos poner son: emacs vim * nano Configuraci\u00f3n de commits por defecto En un entorno de trabajo grande, estaremos haciendo una gran cantidad de commits, es posible tener preconfigurado una plantilla para nuestro commit, para ello usaremos: git config --global commit.template ~/.gitmessage.txt Siendo ~/.gitmessage.txt el archivo que contiene la plantilla","title":"Instalaci\u00f3n y configuraci\u00f3n de git"},{"location":"instalacion-git/#aspectos-basicos-de-git","text":"","title":"Aspectos b\u00e1sicos de Git"},{"location":"instalacion-git/#instalacion","text":"","title":"Instalaci\u00f3n"},{"location":"instalacion-git/#instalando-en-linux","text":"Si quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum: yum install git-core O si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get: apt-get install git","title":"Instalando en Linux"},{"location":"instalacion-git/#instalando-en-windows","text":"Instalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo: http://msysgit.github.com/ Una vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador.","title":"Instalando en Windows"},{"location":"instalacion-git/#instalando-en-macos","text":"En MacOS se recomienda tener instalada la herramienta homebrew . Despu\u00e9s, es tan f\u00e1cil como ejecutar: brew install git","title":"Instalando en MacOS"},{"location":"instalacion-git/#configuracion-del-entorno-git","text":"Git tiene ciertos valores por defecto que nos permite comenzar a trabajar despu\u00e9s de la instalaci\u00f3n, sin embargo, cuando estamos trabajando en conjunto con otras personas es necesario identificarnos dentro de git, de forma que podamos identificar los commits que estemos realizado. Para ello modificaremos los siguientes par\u00e1metros.","title":"Configuraci\u00f3n del entorno git"},{"location":"instalacion-git/#configuracion-de-usuario","text":"git config --global user.name Nombre de usuario git config --global user.email correo_usuario@gmail.com Con estos sencillos comandos tenemos configurados tanto nuestro nombre de usuario como nuestro correo electr\u00f3nico de forma que al subir nuestros cambios al repositorio remoto aparezca nuestro nombre en \u00e9l.","title":"Configuraci\u00f3n de usuario"},{"location":"instalacion-git/#configuracion-de-un-editor-por-defecto","text":"Cuando estamos trabajando con git, es posible que obtengamos dieferentes mensajes de error, dichos mensajes de error ser\u00e1n mostrados en un editor de texto (que por defecto es vim ), podemos cambiar este editor con el siguiente comando. git config --global core.editor editorFavorito Algunos de los editores que podemos poner son: emacs vim * nano","title":"Configuraci\u00f3n de un editor por defecto"},{"location":"instalacion-git/#configuracion-de-commits-por-defecto","text":"En un entorno de trabajo grande, estaremos haciendo una gran cantidad de commits, es posible tener preconfigurado una plantilla para nuestro commit, para ello usaremos: git config --global commit.template ~/.gitmessage.txt Siendo ~/.gitmessage.txt el archivo que contiene la plantilla","title":"Configuraci\u00f3n de commits por defecto"},{"location":"introduccion-git/","text":"Introducci\u00f3n a git Git es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos. Los tres estados Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n. Esto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area). Flujos de trabajo distribuidos con git Hemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git. Flujo de trabajo centralizado Existe un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero Flujo de trabajo del Gestor-de-Integraciones Al permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto. !!! info Este modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante. Flujo de trabajo con Dictador y Tenientes Es una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.","title":"Introducci\u00f3n a git"},{"location":"introduccion-git/#introduccion-a-git","text":"Git es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos.","title":"Introducci\u00f3n a git"},{"location":"introduccion-git/#los-tres-estados","text":"Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n. Esto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area).","title":"Los tres estados"},{"location":"introduccion-git/#flujos-de-trabajo-distribuidos-con-git","text":"Hemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git.","title":"Flujos de trabajo distribuidos con git"},{"location":"introduccion-git/#flujo-de-trabajo-centralizado","text":"Existe un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero","title":"Flujo de trabajo centralizado"},{"location":"introduccion-git/#flujo-de-trabajo-del-gestor-de-integraciones","text":"Al permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto. !!! info Este modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante.","title":"Flujo de trabajo del Gestor-de-Integraciones"},{"location":"introduccion-git/#flujo-de-trabajo-con-dictador-y-tenientes","text":"Es una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.","title":"Flujo de trabajo con Dictador y Tenientes"},{"location":"ramas/","text":"Ramas \u00bfQu\u00e9 son las ramas? Es la forma para separar la l\u0131\u0301nea actual de desarrollo con respecto a la principal. Normalmente representan versiones del software que posteriormente son integradas a la l\u0131\u0301nea principal. \u00bfC\u00f3mo me puedo aprovechar de ellas? Cuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable. preparacion del ejemplo. Para poder llevar a acabo el ejemplo, haremos, (en un directorio vac\u00edo) lo siguiente: git init touch .gitignore git add * git commit -m \"initial commit\" Vamos a crear una rama. !!! info Si usamos git branch sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas disponibles. Una vez hemos comprobado que no existe una rama 'test' podemos proceder a su creaci\u00f3n. $ git chechout -b hola Switched to branch 'hola' Modificamos la nueva rama. para esto a\u00f1adiremos un simple hola mundo en SH, creamos un documento nuevo, llamado \"HelloWorld.sh\" en el cual escribiremos: #!/bin/sh printf \"hello, world\\n\" Salvamos las modificaciones a la rama. $ git add HelloWorld.sh $ git commit -m \"A\u00f1adido script hola mundo\" [hola daae9ca] A\u00f1adido script hola mundo 1 file changed, 3 insertions(+) create mode 100644 HelloWorld.sh Merge al master. Una vez provado el nuevo cambio, vemos que no da errores, entonces decidimos implementarlo al master, para ello, nos iremos al master: $ git checkout master y haremos mergin desde la rama hola, a la rama master. $ git merge hola Updating daae9ca..787590a Fast-forward HelloWorld.sh | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) mergin A continuaci\u00f3n forzaremos una situacion de conflicto entre ramas, para ello modificaremos el script en las dos ramas a la vez. en la rama master, editaremos el script a\u00f1adiendo una exclamaci\u00f3n al final del printf. #!/bin/sh printf \"hello, world!\\n\" A continuacion haremos un commit de lo modificado $ git commit -am \"added \\!\" en la rama hola, a\u00f1adiremos una interrogaci\u00f3n, para ello, nos cambiamos a la rama hola: $ git checkout hola y editamos el script: #!/bin/sh printf \"hello, world?\\n\" A continuacion haremos un commit de lo modificado $ git commit -am \"added ?\" ahora volveremos a la rama master e intentaremos hacer mergin. $ git merge hola Auto-merging HelloWorld.sh CONFLICT (content): Merge conflict in HelloWorld.sh Automatic merge failed; fix conflicts and then commit the result. Esto indica que el mergin fallo en le archivo HelloWorld.sh y que debemos arreglarlo a mano, para ello, abriremos el script de nuevo, esta vez observaremos que unas marcas se han a\u00f1adido: #!/bin/sh HEAD printf \"hello, world!\\n\" ======= printf \"hello, world?\\n\" hola Estas marcas lo que indican el trozo de c\u00f3digo que ha entrado en conflicto, para arreglarlo eliminaremos uno u otro, y procederemos a hacer commit de lo realizado, para este problema, escogeremos el contenido de la rama hola. #!/bin/sh printf \"hello, world?\\n\" $ git commit -am \"fixed mergin problem with branch \\\"hola\\\"\"","title":"Ramas"},{"location":"ramas/#ramas","text":"","title":"Ramas"},{"location":"ramas/#que-son-las-ramas","text":"Es la forma para separar la l\u0131\u0301nea actual de desarrollo con respecto a la principal. Normalmente representan versiones del software que posteriormente son integradas a la l\u0131\u0301nea principal.","title":"\u00bfQu\u00e9 son las ramas?"},{"location":"ramas/#como-me-puedo-aprovechar-de-ellas","text":"Cuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable.","title":"\u00bfC\u00f3mo me puedo aprovechar de ellas?"},{"location":"ramas/#preparacion-del-ejemplo","text":"Para poder llevar a acabo el ejemplo, haremos, (en un directorio vac\u00edo) lo siguiente: git init touch .gitignore git add * git commit -m \"initial commit\"","title":"preparacion del ejemplo."},{"location":"ramas/#vamos-a-crear-una-rama","text":"!!! info Si usamos git branch sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas disponibles. Una vez hemos comprobado que no existe una rama 'test' podemos proceder a su creaci\u00f3n. $ git chechout -b hola Switched to branch 'hola'","title":"Vamos a crear una rama."},{"location":"ramas/#modificamos-la-nueva-rama","text":"para esto a\u00f1adiremos un simple hola mundo en SH, creamos un documento nuevo, llamado \"HelloWorld.sh\" en el cual escribiremos: #!/bin/sh printf \"hello, world\\n\"","title":"Modificamos la nueva rama."},{"location":"ramas/#salvamos-las-modificaciones-a-la-rama","text":"$ git add HelloWorld.sh $ git commit -m \"A\u00f1adido script hola mundo\" [hola daae9ca] A\u00f1adido script hola mundo 1 file changed, 3 insertions(+) create mode 100644 HelloWorld.sh","title":"Salvamos las modificaciones a la rama."},{"location":"ramas/#merge-al-master","text":"Una vez provado el nuevo cambio, vemos que no da errores, entonces decidimos implementarlo al master, para ello, nos iremos al master: $ git checkout master y haremos mergin desde la rama hola, a la rama master. $ git merge hola Updating daae9ca..787590a Fast-forward HelloWorld.sh | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)","title":"Merge al master."},{"location":"ramas/#mergin","text":"A continuaci\u00f3n forzaremos una situacion de conflicto entre ramas, para ello modificaremos el script en las dos ramas a la vez. en la rama master, editaremos el script a\u00f1adiendo una exclamaci\u00f3n al final del printf. #!/bin/sh printf \"hello, world!\\n\" A continuacion haremos un commit de lo modificado $ git commit -am \"added \\!\" en la rama hola, a\u00f1adiremos una interrogaci\u00f3n, para ello, nos cambiamos a la rama hola: $ git checkout hola y editamos el script: #!/bin/sh printf \"hello, world?\\n\" A continuacion haremos un commit de lo modificado $ git commit -am \"added ?\" ahora volveremos a la rama master e intentaremos hacer mergin. $ git merge hola Auto-merging HelloWorld.sh CONFLICT (content): Merge conflict in HelloWorld.sh Automatic merge failed; fix conflicts and then commit the result. Esto indica que el mergin fallo en le archivo HelloWorld.sh y que debemos arreglarlo a mano, para ello, abriremos el script de nuevo, esta vez observaremos que unas marcas se han a\u00f1adido: #!/bin/sh HEAD printf \"hello, world!\\n\" ======= printf \"hello, world?\\n\" hola Estas marcas lo que indican el trozo de c\u00f3digo que ha entrado en conflicto, para arreglarlo eliminaremos uno u otro, y procederemos a hacer commit de lo realizado, para este problema, escogeremos el contenido de la rama hola. #!/bin/sh printf \"hello, world?\\n\" $ git commit -am \"fixed mergin problem with branch \\\"hola\\\"\"","title":"mergin"},{"location":"referencias/","text":"Referencias Documentaci\u00f3n oficial en ingl\u00e9s . Documentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta) . Curso de Git (ingl\u00e9s) . La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso. Curso interactivo de Git (ingl\u00e9s) . P\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s) . Chuleta con las \u00f3rdenes m\u00e1s usuales de Git . Gitmagic (ingles y espa\u00f1ol). Otro manual de Git Art\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git . Curso detallado y gratuito sobre Git y github Otra guia r\u00e1pida de git Gu\u00eda de estilos seg\u00fan Udacity","title":"Referencias"},{"location":"referencias/#referencias","text":"Documentaci\u00f3n oficial en ingl\u00e9s . Documentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta) . Curso de Git (ingl\u00e9s) . La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso. Curso interactivo de Git (ingl\u00e9s) . P\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s) . Chuleta con las \u00f3rdenes m\u00e1s usuales de Git . Gitmagic (ingles y espa\u00f1ol). Otro manual de Git Art\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git . Curso detallado y gratuito sobre Git y github Otra guia r\u00e1pida de git Gu\u00eda de estilos seg\u00fan Udacity","title":"Referencias"},{"location":"uso-avanzado/","text":"Uso avanzado de Git Deshacer cambios Deshaciendo cambios antes de la fase de staging. Volvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos: $ git checkout master Previous HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto Switched to branch 'master' Modificamos hello.cpp de la siguiente manera: #include iostream int main(int argc, char* argv[]){ //Me he equivocado en el comentario, pero la funcion hace eso :-) if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y comprobamos: $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) El mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos: $ git checkout hola.php $ git status En la rama master nada para hacer commit, el \u00e1rbol de trabajo esta limpio $ cat hola.php #include iostream int main(int argc, char* argv[]){ //Funcion para comprobar los numeros de parametros if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Deshaciendo cambios antes del commit Vamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al staging (sin hacer commit ). As\u00ed que volvemos a modificar hello.cpp igual que la anterior ocasi\u00f3n: #include iostream int main(int argc, char* argv[]){ //Enserio, sigo fallando en comentarios. Help me please :/ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y lo a\u00f1adimos al staging $ git add hello.cpp $ git status En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) modificado: hello.cpp De nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio: $ git reset HEAD hello.cpp Cambios fuera del \u00e1rea de stage tras el reset: M hello.cpp $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) $ git checkout hello.cpp Y ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos: uno para borrar los datos del staging y otro para restaurar la copia de trabajo. Deshaciendo commits no deseados. Si a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden git revert . Modificamos otra vez el archivo como antes: #include iostream int main(int argc, char* argv[]){ // 3\u00ba vez que fallo en el comentario, me voy a cambiar de carrera if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Pero ahora s\u00ed hacemos commit: $ git add hello.cpp $ git commit -m Fallo en el comentario y lloro [master 09e9f8b] Fallo en el comentario y lloro 1 file changed, 1 insertion(+), 1 deletion(-) Bien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden git revert : $ git revert HEAD --no-edit [master 41f3998] Revert Fallo en el comentario y lloro Date: Mon Oct 1 18:20:00 2018 +0200 1 file changed, 1 insertion(+), 1 deletion(-) $ git hist * 41f3998 2018-10-01 | Revert Fallo en el comentario y lloro (HEAD - master) [cyberh99] * 09e9f8b 2018-10-01 | Fallo en el comentario y lloro [cyberh99] * 8ca08af 2018-10-01 | Agregamos comentarios [cyberh99] * 506066a 2018-10-01 | Cambiado el mensaje por defecto [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99] Borrar commits de una rama El anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden git reset . $ git reset --hard v1 HEAD est\u00e1 ahora en 506066a Cambiado el mensaje por defecto $ git hist * 506066a 2018-10-01 | Cambiado el mensaje por defecto (HEAD - master) [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99] El resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final. !!! danger La orden reset es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo, sobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios lo cual puede provocar problemas de sincronizaci\u00f3n. Modificar un commit Esto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos nuestro archivo hello.cpp de la siguiente manera: #include iostream //Coded by god //or by @cyberh99 who knows? int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y lo confirmamos: $ git commit -a -m A\u00f1adido el autor del programa [master c9a1ea1] Agregados comentarios s\u00faper \u00fatiles 1 file changed, 3 insertions(+) tip El par\u00e1metro -a hace un git add antes de hacer commit de todos los archivos modificados o borrados (de los nuevos no), con lo que nos ahorramos un paso. Ahora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo: #include iostream //Coded by god //or by @cyberh99 who knows? //okay... it's @cyberh99 int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y en esta ocasi\u00f3n usamos commit --amend que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual: $ git add hola.php $ git commit --amend -m A\u00f1adido el autor del programa y su email [master 80919aa] A\u00f1adido comentario aclarativo Date: Mon Oct 1 18:23:25 2018 +0200 1 file changed, 4 insertions(+) $ git hist * 80919aa 2018-10-01 | A\u00f1adido comentario aclarativo (HEAD - master) [cyberh99] * 506066a 2018-10-01 | Cambiado el mensaje por defecto [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99] danger Nunca modifiques un commit que ya hayas sincronizado con otro repositorio o que hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas problemas de sincronizaci\u00f3n. Moviendo y borrando archivos Mover un archivo a otro directorio con git Para mover archivos usaremos la orden git mv : $ mkdir src $ git mv hello.cpp src $ git status En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) renombrado: hello.cpp - src/hello.cpp Mover y borrar archivos. Pod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema mv y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes: $ mkdir src $ mv hello.cpp src $ git add src/hello.cpp $ git rm hello.cpp Y, ahora s\u00ed, ya podemos guardar los cambios: $ git commit -m Movido hola.php a lib. [master 2bfbc0d] Moivido a src 1 file changed, 0 insertions(+), 0 deletions(-) rename hello.cpp = src/hello.cpp (100%)","title":"Uso avanzado"},{"location":"uso-avanzado/#uso-avanzado-de-git","text":"","title":"Uso avanzado de Git"},{"location":"uso-avanzado/#deshacer-cambios","text":"","title":"Deshacer cambios"},{"location":"uso-avanzado/#deshaciendo-cambios-antes-de-la-fase-de-staging","text":"Volvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos: $ git checkout master Previous HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto Switched to branch 'master' Modificamos hello.cpp de la siguiente manera: #include iostream int main(int argc, char* argv[]){ //Me he equivocado en el comentario, pero la funcion hace eso :-) if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y comprobamos: $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) El mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos: $ git checkout hola.php $ git status En la rama master nada para hacer commit, el \u00e1rbol de trabajo esta limpio $ cat hola.php #include iostream int main(int argc, char* argv[]){ //Funcion para comprobar los numeros de parametros if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; }","title":"Deshaciendo cambios antes de la fase de staging."},{"location":"uso-avanzado/#deshaciendo-cambios-antes-del-commit","text":"Vamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al staging (sin hacer commit ). As\u00ed que volvemos a modificar hello.cpp igual que la anterior ocasi\u00f3n: #include iostream int main(int argc, char* argv[]){ //Enserio, sigo fallando en comentarios. Help me please :/ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y lo a\u00f1adimos al staging $ git add hello.cpp $ git status En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) modificado: hello.cpp De nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio: $ git reset HEAD hello.cpp Cambios fuera del \u00e1rea de stage tras el reset: M hello.cpp $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) $ git checkout hello.cpp Y ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos: uno para borrar los datos del staging y otro para restaurar la copia de trabajo.","title":"Deshaciendo cambios antes del commit"},{"location":"uso-avanzado/#deshaciendo-commits-no-deseados","text":"Si a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden git revert . Modificamos otra vez el archivo como antes: #include iostream int main(int argc, char* argv[]){ // 3\u00ba vez que fallo en el comentario, me voy a cambiar de carrera if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Pero ahora s\u00ed hacemos commit: $ git add hello.cpp $ git commit -m Fallo en el comentario y lloro [master 09e9f8b] Fallo en el comentario y lloro 1 file changed, 1 insertion(+), 1 deletion(-) Bien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden git revert : $ git revert HEAD --no-edit [master 41f3998] Revert Fallo en el comentario y lloro Date: Mon Oct 1 18:20:00 2018 +0200 1 file changed, 1 insertion(+), 1 deletion(-) $ git hist * 41f3998 2018-10-01 | Revert Fallo en el comentario y lloro (HEAD - master) [cyberh99] * 09e9f8b 2018-10-01 | Fallo en el comentario y lloro [cyberh99] * 8ca08af 2018-10-01 | Agregamos comentarios [cyberh99] * 506066a 2018-10-01 | Cambiado el mensaje por defecto [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99]","title":"Deshaciendo commits no deseados."},{"location":"uso-avanzado/#borrar-commits-de-una-rama","text":"El anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden git reset . $ git reset --hard v1 HEAD est\u00e1 ahora en 506066a Cambiado el mensaje por defecto $ git hist * 506066a 2018-10-01 | Cambiado el mensaje por defecto (HEAD - master) [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99] El resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final. !!! danger La orden reset es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo, sobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios lo cual puede provocar problemas de sincronizaci\u00f3n.","title":"Borrar commits de una rama"},{"location":"uso-avanzado/#modificar-un-commit","text":"Esto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos nuestro archivo hello.cpp de la siguiente manera: #include iostream //Coded by god //or by @cyberh99 who knows? int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y lo confirmamos: $ git commit -a -m A\u00f1adido el autor del programa [master c9a1ea1] Agregados comentarios s\u00faper \u00fatiles 1 file changed, 3 insertions(+) tip El par\u00e1metro -a hace un git add antes de hacer commit de todos los archivos modificados o borrados (de los nuevos no), con lo que nos ahorramos un paso. Ahora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo: #include iostream //Coded by god //or by @cyberh99 who knows? //okay... it's @cyberh99 int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y en esta ocasi\u00f3n usamos commit --amend que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual: $ git add hola.php $ git commit --amend -m A\u00f1adido el autor del programa y su email [master 80919aa] A\u00f1adido comentario aclarativo Date: Mon Oct 1 18:23:25 2018 +0200 1 file changed, 4 insertions(+) $ git hist * 80919aa 2018-10-01 | A\u00f1adido comentario aclarativo (HEAD - master) [cyberh99] * 506066a 2018-10-01 | Cambiado el mensaje por defecto [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99] danger Nunca modifiques un commit que ya hayas sincronizado con otro repositorio o que hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas problemas de sincronizaci\u00f3n.","title":"Modificar un commit"},{"location":"uso-avanzado/#moviendo-y-borrando-archivos","text":"","title":"Moviendo y borrando archivos"},{"location":"uso-avanzado/#mover-un-archivo-a-otro-directorio-con-git","text":"Para mover archivos usaremos la orden git mv : $ mkdir src $ git mv hello.cpp src $ git status En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) renombrado: hello.cpp - src/hello.cpp","title":"Mover un archivo a otro directorio con git"},{"location":"uso-avanzado/#mover-y-borrar-archivos","text":"Pod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema mv y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes: $ mkdir src $ mv hello.cpp src $ git add src/hello.cpp $ git rm hello.cpp Y, ahora s\u00ed, ya podemos guardar los cambios: $ git commit -m Movido hola.php a lib. [master 2bfbc0d] Moivido a src 1 file changed, 0 insertions(+), 0 deletions(-) rename hello.cpp = src/hello.cpp (100%)","title":"Mover y borrar archivos."},{"location":"uso-basico/","text":"Uso b\u00e1sico de Git Crear un proyecto Crear un programa \"Hola Mundo\" Creamos un directorio donde colocar el c\u00f3digo mkdir curso-de-git cd curso-de-git Creamos un fichero README.md que muestre una descripci\u00f3n de nuestro proyecto. #Curso de git ASL Crear el repositorio Para crear un nuevo repositorio se usa la orden git init $ git init Inicializado repositorio Git vac\u00edo en /home/cyberh99/code/curso-de-git/.git/ A\u00f1adir la aplicaci\u00f3n Vamos a almacenar el archivo que hemos creado para presentar el proyecto, este ser\u00e1 siempre uno de los primeros commits que tenemos que realizar. $ git add README.md $ git commit -m initial commit [master (commit-ra\u00edz) afdd3c3] initial commit 1 file changed, 1 insertion(+) create mode 100644 README.md Comprobar el estado del repositorio Creamos un fichero hello.cpp que muestre Hola Mundo, este ser\u00e1 el primer archivo para desarrollar nuestro proyecto #include iostream int main(){ std::cout Hello World std::endl; return 0; } Con la orden git status podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio. $ git status En la rama master Archivos sin seguimiento: (usa git add archivo ... para incluirlo a lo que se ser\u00e1 confirmado) hello.cpp no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa git add para hacerles seguimiento) Si volvemos a agregar nuestro nuevo archivo a git, veremos como cambia la salida del comando $ git add hello.cpp $ git commit -m Comenzamos el proyecto [master 24a4f96] comenzamos el proyecto 1 file changed, 6 insertions(+) create mode 100644 hello.cpp $ git status En la rama master nada para hacer commit, el \u00e1rbol de trabajo esta limpio Si modificamos el archivo hola.cpp : #include iostream int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] std::endl; return 0; } Y volvemos a comprobar el estado del repositorio: $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) A\u00f1adir cambios Con la orden git add indicamos a git que prepare los cambios para que sean almacenados. $ git add hello.cpp $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD file ...\" to unstage) # # modified: hello.cpp # Confirmar los cambios Con la orden git commit confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio. $ git commit -m Parametrizaci\u00f3n del programa [master 4a4ad0d] Agregados parametros 1 file changed, 6 insertions(+), 3 deletions(-) $ git status # On branch master nothing to commit (working directory clean) Diferencias entre workdir y staging . Modificamos nuestra aplicaci\u00f3n para que muestre otro mensaje y a\u00f1adimos los cambios. #include iostream int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Este vez a\u00f1adimos los cambios a la fase de staging pero sin confirmarlos ( commit ). $ git add hello.cpp Volvemos a modificar el programa para indicar con un comentario lo que hemos hecho. #include iostream int main(int argc, char* argv[]){ //Funcion para comprobar los numeros de parametros if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y vemos el estado en el que est\u00e1 el repositorio $ git status En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) modificado: hello.cpp Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp Podemos ver como aparecen el archivo hello.cpp dos veces. El primero est\u00e1 preparado para ser confirmado y est\u00e1 almacenado en la zona de staging . El segundo indica que el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo ( workdir ). warning : Si volvieramos a hacer un git add hello.cpp sobreescribir\u00edamos los cambios previos que hab\u00eda en la zona de staging . Almacenamos los cambios por separado: $ git commit -m Cambiado el mensaje por defecto [master 506066a] Cambiado el mensaje por defecto 1 file changed, 1 insertion(+), 1 deletion(-) $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) $ git add . $ git status # En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) modificado: hello.cpp $ git commit -m Agregamos comentarios [master 8ca08af] Agregamos comentarios 1 file changed, 2 insertions(+) info El valor \".\" despues de git add indica que se a\u00f1adan todos los archivos de forma recursiva. warning Cuidado cuando uses git add . aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir. Ignorando archivos La orden git add . o git add nombre_directorio es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible. Por lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de C/C++ , los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen. Para indicarle a git que debe ignorar un archivo, se puede crear un fichero llamado .gitignore , bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente: # .gitignore dir1/ # ignora todo lo que contenga el directorio dir1 !dir1/info.txt # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda) dir2/*.txt # ignora todos los archivos txt que hay en el directorio dir2 dir3/**/*.txt # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios *.o # ignora todos los archivos con extensi\u00f3n .o en todos los directorios Cada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un .gitignore apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en https://github.com/github/gitignore Ignorando archivos globalmente Si bien, los archivos que hemos metido en .gitignore , deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un gitignore que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo ( *~ , .nfs* ) y los que generan los entornos de desarrollo. Para indicar a git que queremos tener un fichero de gitignore global, tenemos que configurarlo con la siguiente orden: git config --global core.excludesfile $HOME/.gitignore_global Ahora podemos crear un archivo llamado .gitignore_global en la ra\u00edz de nuestra cuenta con este contenido: # Compiled source # ################### *.com *.class *.dll *.exe *.o *.so # Packages # ############ # it's better to unpack these files and commit the raw source # git has its own built in compression methods *.7z *.dmg *.gz *.iso *.jar *.rar *.tar *.zip # Logs and databases # ###################### *.log *.sql *.sqlite # OS generated files # ###################### .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db *~ *.swp # IDEs # ###################### .idea .settings/ .classpath .project Trabajando con el historial Observando los cambios Con la orden git log podemos ver todos los cambios que hemos hecho: $ git log commit 8ca08af5c30f5d715f85532592d2ddf99223907f (HEAD - master) Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:18:04 2018 +0200 Agregamos comentarios commit 506066a73012aaa110eba39a8756fddb150a4bb8 Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:16:51 2018 +0200 Cambiado el mensaje por defecto commit 4a4ad0d8b74b4e1ad91bb960ec28f81ffaa3e22c Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:12:23 2018 +0200 Agregados parametros commit 24a4f969086f4b3eaf8f33d1bc883590395c5f04 Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:06:18 2018 +0200 comenzamos el proyecto commit afdd3c3d5ee6037ace39daa2fb9dbaceacb94347 Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 16:58:09 2018 +0200 initial commit Tambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros: $ git log --oneline 8ca08af (HEAD - master) Agregamos comentarios 506066a Cambiado el mensaje por defecto 4a4ad0d Agregados parametros 24a4f96 comenzamos el proyecto afdd3c3 initial commit git log --oneline --max-count=2 git log --oneline --since='5 minutes ago' git log --oneline --until='5 minutes ago' git log --oneline --author=sergio git log --oneline --all Una versi\u00f3n muy \u00fatil de git log es la siguiente, pues nos permite ver en que lugares est\u00e1 master y HEAD, entre otras cosas: $ git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short * 8ca08af 2018-10-01 | Agregamos comentarios (HEAD - master) [cyberh99] * 506066a 2018-10-01 | Cambiado el mensaje por defecto [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99] Crear alias Como estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello editaremos un archivo llamado .gitconfig que est\u00e1 en nuestro $HOME y le a\u00f1adiremos estas l\u00edneas al final: [alias] hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short Recuperando versiones anteriores Cada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden git checkout . $ git checkout e19f2c1 Nota: actualizando el \u00e1rbol de trabajo '4a4ad0d'. Te encuentras en estado 'detached HEAD'. Puedes revisar por aqu\u00ed, hacer cambios experimentales y confirmarlos, y puedes descartar cualquier commit que hayas hecho en este estado sin impactar a tu rama realizando otro checkout. Si quieres crear una nueva rama para mantener los commits que has creado, puedes hacerlo (ahora o despu\u00e9s) usando -b con el comando checkout. Ejemplo: git checkout -b nombre-de-nueva-rama HEAD est\u00e1 ahora en 4a4ad0d Agregados parametros $ cat hello.cpp #include iostream int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] std::endl; return 0; } El aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos. Volver a la \u00faltima versi\u00f3n de la rama master. Usamos git checkout indicando el nombre de la rama: $ git checkout master La posici\u00f3n previa de HEAD era 4a4ad0d Agregados parametros Cambiado a rama 'master' Etiquetando versiones Para poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden git tag . $ git tag v1 Ahora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores ^ o ~ que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes: $ git checkout v1^ $ git checkout v1~1 $ git tag v1-beta Si ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes. $ git tag v1 v1-beta Y para verlas en el historial: $ git hist master --all Borrar etiquetas Para borrar etiquetas: git tag -d nombre_etiqueta Visualizar cambios Para ver los cambios que se han realizado en el c\u00f3digo usamos la orden git diff . La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden git add . Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo: $ git diff v1-beta v1 index 0b00757..bb1c5b7 100644 --- a/hello.cpp +++ b/hello.cpp @@ -1,11 +1,9 @@ #include iostream int main(int argc, char* argv[]){ - //Funcion para comprobar los numeros de parametros if (argc 2){ std::cout Usage: hello Nombre std::endl; } - std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; }","title":"Uso b\u00e1sico"},{"location":"uso-basico/#uso-basico-de-git","text":"","title":"Uso b\u00e1sico de Git"},{"location":"uso-basico/#crear-un-proyecto","text":"","title":"Crear un proyecto"},{"location":"uso-basico/#crear-un-programa-hola-mundo","text":"Creamos un directorio donde colocar el c\u00f3digo mkdir curso-de-git cd curso-de-git Creamos un fichero README.md que muestre una descripci\u00f3n de nuestro proyecto. #Curso de git ASL","title":"Crear un programa \"Hola Mundo\""},{"location":"uso-basico/#crear-el-repositorio","text":"Para crear un nuevo repositorio se usa la orden git init $ git init Inicializado repositorio Git vac\u00edo en /home/cyberh99/code/curso-de-git/.git/","title":"Crear el repositorio"},{"location":"uso-basico/#anadir-la-aplicacion","text":"Vamos a almacenar el archivo que hemos creado para presentar el proyecto, este ser\u00e1 siempre uno de los primeros commits que tenemos que realizar. $ git add README.md $ git commit -m initial commit [master (commit-ra\u00edz) afdd3c3] initial commit 1 file changed, 1 insertion(+) create mode 100644 README.md","title":"A\u00f1adir la aplicaci\u00f3n"},{"location":"uso-basico/#comprobar-el-estado-del-repositorio","text":"Creamos un fichero hello.cpp que muestre Hola Mundo, este ser\u00e1 el primer archivo para desarrollar nuestro proyecto #include iostream int main(){ std::cout Hello World std::endl; return 0; } Con la orden git status podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio. $ git status En la rama master Archivos sin seguimiento: (usa git add archivo ... para incluirlo a lo que se ser\u00e1 confirmado) hello.cpp no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa git add para hacerles seguimiento) Si volvemos a agregar nuestro nuevo archivo a git, veremos como cambia la salida del comando $ git add hello.cpp $ git commit -m Comenzamos el proyecto [master 24a4f96] comenzamos el proyecto 1 file changed, 6 insertions(+) create mode 100644 hello.cpp $ git status En la rama master nada para hacer commit, el \u00e1rbol de trabajo esta limpio Si modificamos el archivo hola.cpp : #include iostream int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] std::endl; return 0; } Y volvemos a comprobar el estado del repositorio: $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a )","title":"Comprobar el estado del repositorio"},{"location":"uso-basico/#anadir-cambios","text":"Con la orden git add indicamos a git que prepare los cambios para que sean almacenados. $ git add hello.cpp $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD file ...\" to unstage) # # modified: hello.cpp #","title":"A\u00f1adir cambios"},{"location":"uso-basico/#confirmar-los-cambios","text":"Con la orden git commit confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio. $ git commit -m Parametrizaci\u00f3n del programa [master 4a4ad0d] Agregados parametros 1 file changed, 6 insertions(+), 3 deletions(-) $ git status # On branch master nothing to commit (working directory clean)","title":"Confirmar los cambios"},{"location":"uso-basico/#diferencias-entre-workdir-y-staging","text":"Modificamos nuestra aplicaci\u00f3n para que muestre otro mensaje y a\u00f1adimos los cambios. #include iostream int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Este vez a\u00f1adimos los cambios a la fase de staging pero sin confirmarlos ( commit ). $ git add hello.cpp Volvemos a modificar el programa para indicar con un comentario lo que hemos hecho. #include iostream int main(int argc, char* argv[]){ //Funcion para comprobar los numeros de parametros if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; } Y vemos el estado en el que est\u00e1 el repositorio $ git status En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) modificado: hello.cpp Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp Podemos ver como aparecen el archivo hello.cpp dos veces. El primero est\u00e1 preparado para ser confirmado y est\u00e1 almacenado en la zona de staging . El segundo indica que el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo ( workdir ). warning : Si volvieramos a hacer un git add hello.cpp sobreescribir\u00edamos los cambios previos que hab\u00eda en la zona de staging . Almacenamos los cambios por separado: $ git commit -m Cambiado el mensaje por defecto [master 506066a] Cambiado el mensaje por defecto 1 file changed, 1 insertion(+), 1 deletion(-) $ git status En la rama master Cambios no rastreados para el commit: (usa git add archivo ... para actualizar lo que ser\u00e1 confirmado) (usa git checkout -- archivo ... para descartar los cambios en el directorio de trabajo) modificado: hello.cpp sin cambios agregados al commit (usa git add y/o git commit -a ) $ git add . $ git status # En la rama master Cambios a ser confirmados: (usa git reset HEAD archivo ... para sacar del \u00e1rea de stage) modificado: hello.cpp $ git commit -m Agregamos comentarios [master 8ca08af] Agregamos comentarios 1 file changed, 2 insertions(+) info El valor \".\" despues de git add indica que se a\u00f1adan todos los archivos de forma recursiva. warning Cuidado cuando uses git add . aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir.","title":"Diferencias entre workdir y staging."},{"location":"uso-basico/#ignorando-archivos","text":"La orden git add . o git add nombre_directorio es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible. Por lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de C/C++ , los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen. Para indicarle a git que debe ignorar un archivo, se puede crear un fichero llamado .gitignore , bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente: # .gitignore dir1/ # ignora todo lo que contenga el directorio dir1 !dir1/info.txt # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda) dir2/*.txt # ignora todos los archivos txt que hay en el directorio dir2 dir3/**/*.txt # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios *.o # ignora todos los archivos con extensi\u00f3n .o en todos los directorios Cada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un .gitignore apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en https://github.com/github/gitignore","title":"Ignorando archivos"},{"location":"uso-basico/#ignorando-archivos-globalmente","text":"Si bien, los archivos que hemos metido en .gitignore , deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un gitignore que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo ( *~ , .nfs* ) y los que generan los entornos de desarrollo. Para indicar a git que queremos tener un fichero de gitignore global, tenemos que configurarlo con la siguiente orden: git config --global core.excludesfile $HOME/.gitignore_global Ahora podemos crear un archivo llamado .gitignore_global en la ra\u00edz de nuestra cuenta con este contenido: # Compiled source # ################### *.com *.class *.dll *.exe *.o *.so # Packages # ############ # it's better to unpack these files and commit the raw source # git has its own built in compression methods *.7z *.dmg *.gz *.iso *.jar *.rar *.tar *.zip # Logs and databases # ###################### *.log *.sql *.sqlite # OS generated files # ###################### .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db *~ *.swp # IDEs # ###################### .idea .settings/ .classpath .project","title":"Ignorando archivos globalmente"},{"location":"uso-basico/#trabajando-con-el-historial","text":"","title":"Trabajando con el historial"},{"location":"uso-basico/#observando-los-cambios","text":"Con la orden git log podemos ver todos los cambios que hemos hecho: $ git log commit 8ca08af5c30f5d715f85532592d2ddf99223907f (HEAD - master) Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:18:04 2018 +0200 Agregamos comentarios commit 506066a73012aaa110eba39a8756fddb150a4bb8 Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:16:51 2018 +0200 Cambiado el mensaje por defecto commit 4a4ad0d8b74b4e1ad91bb960ec28f81ffaa3e22c Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:12:23 2018 +0200 Agregados parametros commit 24a4f969086f4b3eaf8f33d1bc883590395c5f04 Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 17:06:18 2018 +0200 comenzamos el proyecto commit afdd3c3d5ee6037ace39daa2fb9dbaceacb94347 Author: cyberh99 cyberh99@protonmail.com Date: Mon Oct 1 16:58:09 2018 +0200 initial commit Tambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros: $ git log --oneline 8ca08af (HEAD - master) Agregamos comentarios 506066a Cambiado el mensaje por defecto 4a4ad0d Agregados parametros 24a4f96 comenzamos el proyecto afdd3c3 initial commit git log --oneline --max-count=2 git log --oneline --since='5 minutes ago' git log --oneline --until='5 minutes ago' git log --oneline --author=sergio git log --oneline --all Una versi\u00f3n muy \u00fatil de git log es la siguiente, pues nos permite ver en que lugares est\u00e1 master y HEAD, entre otras cosas: $ git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short * 8ca08af 2018-10-01 | Agregamos comentarios (HEAD - master) [cyberh99] * 506066a 2018-10-01 | Cambiado el mensaje por defecto [cyberh99] * 4a4ad0d 2018-10-01 | Agregados parametros [cyberh99] * 24a4f96 2018-10-01 | comenzamos el proyecto [cyberh99] * afdd3c3 2018-10-01 | initial commit [cyberh99]","title":"Observando los cambios"},{"location":"uso-basico/#crear-alias","text":"Como estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello editaremos un archivo llamado .gitconfig que est\u00e1 en nuestro $HOME y le a\u00f1adiremos estas l\u00edneas al final: [alias] hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short","title":"Crear alias"},{"location":"uso-basico/#recuperando-versiones-anteriores","text":"Cada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden git checkout . $ git checkout e19f2c1 Nota: actualizando el \u00e1rbol de trabajo '4a4ad0d'. Te encuentras en estado 'detached HEAD'. Puedes revisar por aqu\u00ed, hacer cambios experimentales y confirmarlos, y puedes descartar cualquier commit que hayas hecho en este estado sin impactar a tu rama realizando otro checkout. Si quieres crear una nueva rama para mantener los commits que has creado, puedes hacerlo (ahora o despu\u00e9s) usando -b con el comando checkout. Ejemplo: git checkout -b nombre-de-nueva-rama HEAD est\u00e1 ahora en 4a4ad0d Agregados parametros $ cat hello.cpp #include iostream int main(int argc, char* argv[]){ if (argc 2){ std::cout Usage: hello Nombre std::endl; } std::cout Hello World argv[1] std::endl; return 0; } El aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos.","title":"Recuperando versiones anteriores"},{"location":"uso-basico/#volver-a-la-ultima-version-de-la-rama-master","text":"Usamos git checkout indicando el nombre de la rama: $ git checkout master La posici\u00f3n previa de HEAD era 4a4ad0d Agregados parametros Cambiado a rama 'master'","title":"Volver a la \u00faltima versi\u00f3n de la rama master."},{"location":"uso-basico/#etiquetando-versiones","text":"Para poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden git tag . $ git tag v1 Ahora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores ^ o ~ que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes: $ git checkout v1^ $ git checkout v1~1 $ git tag v1-beta Si ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes. $ git tag v1 v1-beta Y para verlas en el historial: $ git hist master --all","title":"Etiquetando versiones"},{"location":"uso-basico/#borrar-etiquetas","text":"Para borrar etiquetas: git tag -d nombre_etiqueta","title":"Borrar etiquetas"},{"location":"uso-basico/#visualizar-cambios","text":"Para ver los cambios que se han realizado en el c\u00f3digo usamos la orden git diff . La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden git add . Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo: $ git diff v1-beta v1 index 0b00757..bb1c5b7 100644 --- a/hello.cpp +++ b/hello.cpp @@ -1,11 +1,9 @@ #include iostream int main(int argc, char* argv[]){ - //Funcion para comprobar los numeros de parametros if (argc 2){ std::cout Usage: hello Nombre std::endl; } - std::cout Hello World argv[1] Bienvenido al curso de git std::endl; return 0; }","title":"Visualizar cambios"}]}